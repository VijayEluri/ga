import java.util.ArrayList;import java.util.List;import java.util.ListIterator;import java.util.Random;public class GA {    public static void main(final String[] args) {        final int target;        if (args.length == 0) {            target = 163;        } else {            target = Integer.parseInt(args[0]);        }        new GA().doIt(target);    }    // Static info    private static final int numberOfBitsPerChromosone = 4;    static char[]            lookupTable               = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-',            '*', '/'                                  };    static int               numberOfChromosones       = 7;    static double            crossRate                 = .7;    static double            mutationRate              = .001;    static Random            rand                      = new Random();    static int               poolSize                  = 40;          // Must be even    private void doIt(final int target) {        int gen = 0;        // Create the pool        final List<Chromosone> pool = new ArrayList<Chromosone>(poolSize);        final List<Chromosone> newPool = new ArrayList<Chromosone>(pool.size());        // Generate unique chromosomes in the pool        for (int x = 0; x < poolSize; x++) {            pool.add(new Chromosone(target));        }        // Loop until solution is found        while (true) {            // Clear the new pool            newPool.clear();            // Add to the generations            gen++;            // Loop until the pool has been processed            for (int x = pool.size() - 1; x >= 0; x -= 2) {                // Select two members                final Chromosone n1 = selectMember(pool);                final Chromosone n2 = selectMember(pool);                // Cross over and mutate                n1.crossOver(n2);                n1.mutate();                n2.mutate();                // Rescore the nodes                n1.scoreChromo(target);                n2.scoreChromo(target);                // Check to see if either is the solution                if (n1.total == target && n1.isValid()) {                    System.out.println("Generations: " + gen + "  Solution: " + n1.decodeChromo());                    return;                }                if (n2.total == target && n2.isValid()) {                    System.out.println("Generations: " + gen + "  Solution: " + n2.decodeChromo());                    return;                }                // Add to the new pool                newPool.add(n1);                newPool.add(n2);            }            // Add the newPool back to the old pool            pool.addAll(newPool);        }    }    // ---- Chromosone Class -----    private Chromosone selectMember(final List<Chromosone> list) {        // Get the total fitness        double sumAcrossAllChromosones = 0.0;        for (final Chromosone node : list) {            final double score = node.score;            sumAcrossAllChromosones += score;        }        final double slice = sumAcrossAllChromosones * rand.nextDouble();        // Loop to find the node        double ttot = 0.0;        final ListIterator<Chromosone> iter = list.listIterator();        while (iter.hasNext()) {            final Chromosone node = iter.next();            ttot += node.score;            if (ttot >= slice) {                iter.remove();                return node;            }        }        return list.remove(list.size() - 1);    }    // Genetic Algorithm Node    private static class Chromosone {        // The chromo        StringBuffer  chromo = new StringBuffer(numberOfChromosones * numberOfBitsPerChromosone);        public double score;        public int    total;        // Constructor that generates a random        public Chromosone(final int target) {            // Create the full buffer            for (int y = 0; y < numberOfChromosones; y++) {                // Generate a random binary integer                final String binString = Integer.toBinaryString(rand.nextInt(lookupTable.length));                final int fillLen = numberOfBitsPerChromosone - binString.length();                // Fill to 4                for (int x = 0; x < fillLen; x++) {                    chromo.append('0');                }                // Append the chromo                chromo.append(binString);            }            // Score the new cromo            scoreChromo(target);        }        // Decode the string        public final String decodeChromo() {            final StringBuffer decodeChromo = new StringBuffer(numberOfChromosones * numberOfBitsPerChromosone);            // Create a buffer            decodeChromo.setLength(0);            // Loop throught the chromo            for (int x = 0; x < chromo.length(); x += numberOfBitsPerChromosone) {                // Get the                final int idx = Integer.parseInt(chromo.substring(x, x + numberOfBitsPerChromosone), 2);                if (idx < lookupTable.length) {                    decodeChromo.append(lookupTable[idx]);                }            }            // Return the string            return decodeChromo.toString();        }        // Scores this chromo        public final void scoreChromo(final int target) {            total = addUp();            if (total == target) {                score = 0;            }            score = (double) 1 / (target - total);        }        // Crossover bits        public final void crossOver(final Chromosone other) {            // Should we cross over?            if (rand.nextDouble() > crossRate) {                return;            }            // Generate a random position            final int pos = rand.nextInt(chromo.length());            // Swap all chars after that position            for (int x = pos; x < chromo.length(); x++) {                // Get our character                final char tmp = chromo.charAt(x);                // Swap the chars                chromo.setCharAt(x, other.chromo.charAt(x));                other.chromo.setCharAt(x, tmp);            }        }        // IMutator        public final void mutate() {            for (int x = 0; x < chromo.length(); x++) {                if (rand.nextDouble() <= mutationRate) {                    chromo.setCharAt(x, (chromo.charAt(x) == '0' ? '1' : '0'));                }            }        }        // Add up the contents of the decoded chromo        public final int addUp() {            // Decode our chromo            final String decodedString = decodeChromo();            // Total            int tot = 0;            // Find the first number            int ptr = 0;            while (ptr < decodedString.length()) {                final char ch = decodedString.charAt(ptr);                if (Character.isDigit(ch)) {                    tot = ch - '0';                    ptr++;                    break;                } else {                    ptr++;                }            }            // If no numbers found, return            if (ptr == decodedString.length()) {                return 0;            }            // Loop processing the rest            boolean num = false;            char oper = ' ';            while (ptr < decodedString.length()) {                // Get the character                final char ch = decodedString.charAt(ptr);                // Is it what we expect, if not - skip                if (num && !Character.isDigit(ch)) {                    ptr++;                    continue;                }                if (!num && Character.isDigit(ch)) {                    ptr++;                    continue;                }                // Is it a number                if (num) {                    switch (oper) {                        case '+': {                            tot += ch - '0';                            break;                        }                        case '-': {                            tot -= ch - '0';                            break;                        }                        case '*': {                            tot *= ch - '0';                            break;                        }                        case '/': {                            if (ch != '0') {                                tot /= ch - '0';                            }                            break;                        }                    }                } else {                    oper = ch;                }                // Go to next character                ptr++;                num = !num;            }            return tot;        }        public final boolean isValid() {            // Decode our chromo            final String decodedString = decodeChromo();            boolean num = true;            for (int x = 0; x < decodedString.length(); x++) {                final char ch = decodedString.charAt(x);                // Did we follow the num-oper-num-oper-num pattern                if (num == !Character.isDigit(ch)) {                    return false;                }                // Don't allow divide by zero                if (x > 0 && ch == '0' && decodedString.charAt(x - 1) == '/') {                    return false;                }                num = !num;            }            // Can't end in an operator            if (!Character.isDigit(decodedString.charAt(decodedString.length() - 1))) {                return false;            }            return true;        }    }}